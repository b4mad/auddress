require 'digest/sha1'
class User < ActiveRecord::Base
  
  # ---------------------------------------
  # The following code has been generated by role_requirement.
  # You may wish to modify it to suit your need
  has_and_belongs_to_many :roles
  has_many :books, :dependent => :destroy
  has_many :people, :dependent => :destroy  # address book entries
  belongs_to :person, :dependent => :destroy # my own personal data

  has_many :events, :dependent => :destroy, :order => 'created_at DESC'
  has_many :duplicates, :dependent => :destroy # duplicate information
  has_many :link_requests, :dependent => :destroy # link requests we have issued
  has_many :uploads, :dependent => :destroy # uploads the user has created
  has_many :sync_sources, :dependent => :destroy
  
  # has_role? simply needs to return true or false whether a user has a role or not.  
  # It may be a good idea to have "admin" roles return true always
  def has_role?(role_in_question)
    @_list ||= self.roles.collect(&:name)
    ## FIXME will return true even on phantasy roles never used/assigned...
    return true if @_list.include?("admin") 
    (@_list.include?(role_in_question.to_s) )
  end
  # ---------------------------------------
  
  # Virtual attribute for the unencrypted password
  attr_accessor :password

  validates_presence_of     :login
  validates_presence_of     :password,                   :if => :password_required?
  validates_presence_of     :password_confirmation,      :if => :password_required?
  validates_length_of       :password, :within => 4..40, :if => :password_required?
  validates_confirmation_of :password,                   :if => :password_required?
  validates_length_of       :login,    :within => 3..40
  validates_uniqueness_of   :login, :case_sensitive => false
  #validates_length_of       :email,    :within => 3..100
  #validates_presence_of     :person
  #validates_length_of       :books, :minimum => 1
  #validates_associated      :books, :person

  #after_create :create_ldap, :add_person
  after_create :add_person, :create_paths
  after_destroy :destroy_paths, :tempfile_unlink_all

  
  before_save :encrypt_password
  #after_save :save_ldap
  
  # prevents a user from submitting a crafted form that bypasses activation
  # anything else you want your user to change should be added here.
  attr_accessible :login, :password, :password_confirmation

  def photo_path
    Conf.path_to_data + '/data/photos/' + self.id.to_s + '/'
  end

  def create_paths
    # FIXME: check mode after we know something about security restrictions
    FileUtils.makedirs(photo_path, :mode => 0770)
  end

  def destroy_paths
    FileUtils.remove_dir(photo_path)
  end

  def tempfile_prefix
    'tmp/' + self.id.to_s + '-'
  end

  def tempfile_unlink_all
    # also remove remaining tempfiles
    FileUtils.rm(Dir.glob(tempfile_prefix + '*'), :force => true)
  end
  
  # Creates a temporary file (which will be deleted on logout)
  def tempfile(data_or_key, action = nil)
    # FIXME: this is a security risk, check filename if it is sane
    begin
      if action == :unlink and data_or_key.is_a?(String)
        File.unlink(tempfile_prefix + data_or_key)
      elsif action == :data and data_or_key.is_a?(String)
        f=File.open(tempfile_prefix + data_or_key, 'r')
        data = f.read
        f.close
        return data
      elsif data_or_key.respond_to?(:read)
        # Find a new unique filename
        filename = ActiveSupport::SecureRandom.hex(16)
        while (File.exist?(tempfile_prefix + filename))
          filename = ActiveSupport::SecureRandom.hex(16)
        end
        # create the file and close it
        f = File.new(tempfile_prefix + filename, 'w')
        f.write(data_or_key.read)
        f.close
        return filename
      else
        return tempfile_prefix + data_or_key
      end
    rescue Errno::ENOENT, Errno::EISDIR
    end
  end

  # Authenticates a user by their login name and unencrypted password.  Returns the user or nil.
  def self.authenticate(login, password)
    u = find_by_login(login) # need to get the salt
    u && u.authenticated?(password) ? u : nil
  end

  # Encrypts some data with the salt.
  def self.encrypt(password, salt)
    Digest::SHA1.hexdigest("--#{salt}--#{password}--")
  end

  # Encrypts the password with the user salt
  def encrypt(password)
    self.class.encrypt(password, salt)
  end

  def authenticated?(password)
    crypted_password == encrypt(password)
  end

  def remember_token?
    remember_token_expires_at && Time.now.utc < remember_token_expires_at 
  end

  # These create and unset the fields required for remembering users between browser closes
  def remember_me
    remember_me_for 2.weeks
  end

  def remember_me_for(time)
    remember_me_until time.from_now.utc
  end

  def remember_me_until(time)
    self.remember_token_expires_at = time
    self.remember_token            = encrypt("#{login}--#{remember_token_expires_at}")
    save(false)
  end

  def forget_me
    self.remember_token_expires_at = nil
    self.remember_token            = nil
    save(false)
  end

  # Returns true if the user has just been activated.
  def recently_activated?
    @activated
  end
  
  def add_person
    person = Person.new
    person.lastname = 'me'
    person.user = self
    person.save
    self.person = person
    self.save
  end

  def book
    #return books.default.first
    books.find_by_name(Book::DEFAULT_NAME) || begin
      book = Book.new(:name => Book::DEFAULT_NAME)
      books << book
      book
    end
  end
  
  def import_book
    books.find_by_name(Book::IMPORT_NAME) || begin
      import_book = Book.new(:name => Book::IMPORT_NAME)
      books << import_book
      import_book
    end
  end

  def trash_book
    books.find_by_name(Book::TRASH_NAME) || begin
      book = Book.new(:name => Book::TRASH_NAME)
      books << book
      book
    end
  end

  # move to trash
  def trash_person(person)
    # make sure its not us
    return false if person == self.person
    #self.trash_book.people << person
    #self.book.people.delete(person)
    person.destroy
  end

#  def create_ldap
#    return unless Conf.store_ldap
#    begin
#      if UserLdap.exists?(login)
#        # FIXME: how should we deal with this? on create the user cannot exist
#        # in ldap! Anyway, we take this one and assume it just has not been created
#        #raise Exception, 'User already taken in LDAP'
#        ldap = UserLdap.find(login)
#      else
#        ldap = UserLdap.new
#      end
#      ldap.cn = login
#      ldap.sn = login
#      ldap.save
#      ldap
#    rescue ActiveLdap::ConnectionError
#      logger.fatal "ActiveLdap::ConnectionError in User::create_ldap - User incomplete"
#    end
#  end
  
  # OPTIMIZE: maybe move this to user_ldap ?
#  def save_ldap
#    return unless Conf.store_ldap
#    # only save to ldap if the user is new, or updates his password
#    return unless password_required?
#
#    begin
#      if UserLdap.exists?(login)
#        ldap = UserLdap.find(login)
#      else
#        ldap = create_ldap
#        # FIXME raise Exception, 'User does not exist in LDAP'
#      end
#
#      # http://www.openldap.org/faq/data/cache/347.html
#      require 'base64'
#      ldap.userPassword =
#      "{SSHA}"+Base64.encode64(Digest::SHA1.digest(password+salt)+salt).chomp!
#      ldap.save
#    rescue
#      logger.fatal "LDAP Errors: " + ActiveLdap::ConnectionError.to_s
#    end
#  end


  protected
    # before filter 
    def encrypt_password
      return if password.blank?
      self.salt = Digest::SHA1.hexdigest("--#{Time.now.to_s}--#{login}--") if new_record?
      self.crypted_password = encrypt(password)
    end
      
    def password_required?
      crypted_password.blank? || !password.blank?
    end
    
end
